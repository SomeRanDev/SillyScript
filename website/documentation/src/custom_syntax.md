# Custom Syntax

SillyScript is about being silly; what's more silly than programming your programming language in your programming language? How certain statements should be generated for each project may be different, so it's up to the user to describe which statements are supported and how they are generated.

The `syntax` keyword can be used to create custom syntax. The structure of a custom syntax declaration looks like this:

```SillyScript
syntax NAME:
	pattern:
		PATTERN

	TRANSMUTE_FUNCTION
```

<table>
  <tr>
    <th>Input</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>NAME</code></td>
    <td>A globally unique name for your syntax declaration.</td>
  </tr>
  <tr>
    <td><code>PATTERN</code></td>
    <td>The syntax template this declaration adds.</td>
  </tr>
  <tr>
  	<td><code>TRANSMUTE_FUNCTION</code></td>
    <td>A function that generates the data generated by this syntax. Its arguments should match with the arguments set up in triangle-brackets in the pattern.</td>
  </tr>
</table>

## If Example

Let's start by adding a simple `if` statement.

```SillyScript
syntax If:
	pattern:
		if <condition: dict!condition>:
			<contents: dict!action list>

	def transmute(condition: dict, contents: list) -> dict!action:
		type: 2;
		condition: condition;
		if_true: contents;
		if_false: null;
```

The contents under `pattern` determines the pattern of the syntax. You can put almost anything here, and SillyScript just figures it out. To extract the data contents at specific points, use `<name: type>` at the location.

Now let's see how this syntax is transformed into JSON:

doublecodeblock:
	```SillyScript
	def Comparison(name: string, value: int) -> dict!condition:
		name: name;
		value: value;
		
	def DoThing(action_name: string) -> dict!action:
		action: action_name;
		
	DoThing("Hop");
	if Comparison("something", 123):
		DoThing("Skip");
		DoThing("Jump");
	```

	```JSON
	[
		{ "action": "Hop" },
		{
			"type": 2,
			"condition": {
				"name": "something",
				"value": 123
			},
			"contents": [
				{ "action": "Skip" },
				{ "action": "Jump" },
			]
		}
	]
	```

## Else Example

Let's say we want to allow for an "else" case in our "if" syntax. Let's create a new syntax declaration. We need to add `internal: true` so this syntax isn't available for use with normal code.

```SillyScript
syntax Else:
	pattern:
		else:
			<contents: dict!action list>

	internal: true;

	def transmute(contents: dict!action list) -> dict!action list:
		contents;
```

Now we can add an optional "else" case in our "if" syntax. The `?` after the "else_contents" identifier means this syntax is optional. The "if" still works even if there isn't an "else".

```SillyScript
syntax If:
	pattern:
		if <condition: dict!condition>:
			<contents: dict!action list>
		<else_contents?: syntax!Else>

	def transmute(condition: dict, contents: list, else_contents: dict!action list?) -> dict!action:
		type: 2;
		condition: condition;
		if_true: contents;
		if_false: else_contents;
```

## Custom Operator

Custom operators are also added using syntax declarations.

```SillyScript
syntax IntEquality:
	pattern:
		<left_number: int> == <right_number: int>

	def transmute(left_number: int, right_number: int) -> dict!condition:
		type: 5;
		left_number: left_number;
		right_number: right_number;
```

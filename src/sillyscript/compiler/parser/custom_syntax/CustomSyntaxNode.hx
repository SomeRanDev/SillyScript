package sillyscript.compiler.parser.custom_syntax;

import sillyscript.extensions.Stack;
import sillyscript.compiler.parser.custom_syntax.UntypedCustomSyntaxDeclaration.CustomSyntaxId;
import sillyscript.compiler.lexer.Token;

/**
	The kind of custom syntax node.
**/
enum CustomSyntaxNodeKind {
	/**
		This kind should only exist on the root node.
	**/
	Start;

	/**
		This is an expression that can be placed in the syntax.

		`identifierMap` contains all the custom syntax declaration IDs this node can correlate to
		and maps them to their corresponding "name" defined in their pattern.
	**/
	Expression(identifierMap: Map<CustomSyntaxId, String>);

	/**
		A custom syntax within the custom syntax.
	**/
	Syntax(syntax: CustomSyntaxId, identifierMap: Map<CustomSyntaxId, String>);

	/**
		A node of this kind represents a single token in the syntax.
	**/
	Token(token: Token);
}

/**
	The data for `CustomSyntaxNode` that is separated into its own class so it may be stacked
	correlating to the scopes being parsed.
**/
class CustomSyntaxNodeScope {
	public var nextNodes(default, null): Array<CustomSyntaxNode>;
	public var customSyntaxEndCandidates(default, null): Null<Array<{ id: CustomSyntaxId, patternIndex: Int }>>;

	public function new() {
		nextNodes = [];
		customSyntaxEndCandidates = null;
	}

	public function addCustomSyntaxEndCandidate(declaration: CustomSyntaxId, patternIndex: Int) {
		if(customSyntaxEndCandidates == null) {
			customSyntaxEndCandidates = [];
		}
		customSyntaxEndCandidates.push({
			id: declaration,
			patternIndex: patternIndex
		});
	}
}

/**
	A node in the custom syntax tree that is generated by parsing custom syntax declarations.

	Nodes are added based on new syntaxes supported by custom syntax declarations. For example,
	if there are two syntaxes: += and +|, the syntax tree will have 3 nodes:
		 ↱ (=)
		(+)
		 ↳ (|)
	
	The two final nodes (=) and (|) will both contain one "custom syntax end candidate" since they
	both only have one possible candidate that can get to them by following their tokens.

	If the same syntax is registered multiple times with different types, multiple "end candidates"
	will be returned and determined through typing later.
**/
class CustomSyntaxNode {
	public var kind(default, null): CustomSyntaxNodeKind;

	var scopeStack: Stack<CustomSyntaxNodeScope>;
	var expressionNextNode: Null<CustomSyntaxNode>;

	/**
		Constructor.

		`token` dictates the `CustomSyntaxNodeKind` from a `CustomSyntaxToken`.
		Passing `null` should only be done for the root node of the custom syntax tree.
	**/
	public function new(token: Null<CustomSyntaxToken>) {
		kind = switch(token) {
			case null: Start;
			case Expression: Expression([]);
			case Syntax(id): Syntax(id, []);
			case Token(token): Token(token);
		};

		scopeStack = [];
		expressionNextNode = null;

		pushScope();
	}

	/**
		Pushes a scope that can later pop all subsequent changes made.
	**/
	public function pushScope() {
		scopeStack.pushTop(new CustomSyntaxNodeScope());
	}

	/**
		Sets the state of the node to how it was at the most recent call of `pushScope`.
	**/
	public function popScope() {
		if(scopeStack.length <= 1) {
			return;
		}

		final poppedScope = scopeStack.popTop();

		// Check if the removed scope contained the "expression" next node.
		// If it did, assign `expressionNextNode` back to `null`.
		if(poppedScope != null) {
			for(node in poppedScope.nextNodes) {
				switch(node.kind) {
					case Expression(_): {
						expressionNextNode = null;
						break;
					}
					case _:
				}
			}
		}
	}

	/**
		Attempts to find subsequent node that matches the `Token`.
		If one doesn't exists, it returns `null`.
	**/
	public function getNextNodeFromCurrentToken(token: Token): Null<CustomSyntaxNode> {
		for(scope in scopeStack.bottomToTopIterator()) {
			for(node in scope.nextNodes) {
				final equals = switch(node.kind) {
					case Token(nodeToken): nodeToken.equals(token);
					case _: false;
				}
				if(equals) {
					return node;
				}
			}
		}

		return null;
	}

	/**
		Attempts to find subsequent node that matches the provided `CustomSyntaxToken`.
		If it doesn't exist, one is created with this token and added to this node.
	**/
	public function findOrCreateNextNode(newToken: CustomSyntaxToken): CustomSyntaxNode {
		for(scope in scopeStack.bottomToTopIterator()) {
			for(node in scope.nextNodes) {
				final equals = switch(node.kind) {
					case Start: false;
					case Expression(_): newToken.equals(Expression);
					case Syntax(id, _): newToken.equals(Syntax(id));
					case Token(token): newToken.equals(Token(token));
				}
				if(equals) {
					return node;
				}
			}
		}

		final newNode = new CustomSyntaxNode(newToken);
		final scope = scopeStack.last();
		if(scope != null) {
			scope.nextNodes.push(newNode);
		}

		// If we're adding an "expression" next node, update `nextNodesContainsExpression`.
		switch(newToken) {
			case Expression: expressionNextNode = newNode;
			case _:
		}

		return newNode;
	}

	/**
		Returns an array of all the custom syntax declaration IDs that can end at this
	**/
	public function findCustomSyntaxEndCandidates(): Array<{ id: CustomSyntaxId, patternIndex: Int }> {
		if(scopeStack.length <= 0) {
			return [];
		} else if(scopeStack.length == 1) {
			final scope = scopeStack.last();
			if(scope != null) {
				return scope.customSyntaxEndCandidates ?? [];
			}
		}

		final result = [];
		for(scope in scopeStack.bottomToTopIterator()) {
			if(scope.customSyntaxEndCandidates != null) {
				for(candidate in scope.customSyntaxEndCandidates) {
					result.push(candidate);
				}
			}
		}
		return result;
	}

	/**
		Registers the custom syntax declaration as a candidate for a complete syntax at this node.
	**/
	public function addCustomSyntaxEndCandidate(declaration: CustomSyntaxId, patternIndex: Int) {
		final scope = scopeStack.last();
		if(scope != null) {
			scope.addCustomSyntaxEndCandidate(declaration, patternIndex);
		}
	}

	/**
		If this node has a subsequent node that is an expression input, returns `true`.
	**/
	public function hasExpressionNextNode(): Bool {
		return expressionNextNode != null;
	}

	/**
		If this node has a subsequent node that is an expression input, it returns it.
		Returns `null` otherwise.
	**/
	public function getExpressionNextNode(): Null<CustomSyntaxNode> {
		return expressionNextNode;
	}

	/**
		Returns a list of all `CustomSyntaxId`s that are available as "next" nodes.
		If there are no custom syntax nodes next, `null` is returned.
	**/
	public function getAllSyntaxNextNodeIds(): Null<Array<CustomSyntaxId>> {
		var result = null;
		for(scope in scopeStack.topToBottomIterator()) {
			for(node in scope.nextNodes) {
				switch(node.kind) {
					case Syntax(syntaxId, _): {
						if(result == null) result = [];
						result.push(syntaxId);
					}
					case _:
				}
			}
		}
		return result;
	}

	/**
		If this node has a subsequent node that is a syntax input with ID `id`, it returns it.
		Returns `null` otherwise.
	**/
	public function getSyntaxNextNode(id: CustomSyntaxId): Null<CustomSyntaxNode> {
		for(scope in scopeStack.topToBottomIterator()) {
			for(node in scope.nextNodes) {
				switch(node.kind) {
					case Syntax(syntaxId, _) if(syntaxId == id): return node;
					case _:
				}
			}
		}
		return null;
	}

	/**
		Registers the identifier for the custom syntax declaration that uses this node.
	**/
	public function pushDeclarationExpressionIdentifier(id: CustomSyntaxId, name: String) {
		switch(kind) {
			case Expression(identifierMap) | Syntax(_, identifierMap): {
				identifierMap.set(id, name);
			}
			case _:
		}
	}

	/**
		If this node is an expression input, this returns the map of names for the custom syntax
		declarations' expression inputs keyed by their IDs.

		For example, to figure out what the name of the identifier of the expression for
		this node for the declaration ID #4, it's:
		```haxe
		getDeclarationExpressionIdentifierMap()[4];
		```
	**/
	public function getDeclarationExpressionIdentifierMap(): Map<CustomSyntaxId, String> {
		return switch(kind) {
			case Expression(identifierMap) | Syntax(_, identifierMap): identifierMap;
			case _: [];
		}
	}
}

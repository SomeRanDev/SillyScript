package test;

import haxe.io.Bytes;
import haxe.io.Path;
import sys.FileSystem;
import sys.io.File;
import sys.io.Process;
using StringTools;

/**
	Enum returned by `runTest`.
**/
enum RunTestResult {
	Success;
	TestSuccessfulButNoExpectedOutputJson;
	TestSuccessfulButNoOutputJson;
	TestSuccessfulButDoesntMatch(output: String);
	TestFailedButNoExpectedError(stderrOutput: String);
	TestFailedButDoesntMatch(newErrorOutput: String);
}

/**
	Enum returned by `run` for running an arbitrary command.
**/
enum RunResult {
	Success;
	Error(stderrOutput: String);
}

/**
	The kind of executable used for testing.
**/
enum ExecutableKind {
	Direct(path: String);
	HashLink(path: String);
	NodeJs(path: String);
}

/**
	Template for arguments object generated by `validateArguments`.
**/
typedef Args = {
	executable: ExecutableKind,
	tests: String,
	updateIntended: Bool
};

/**
	If not zero, this script will exit with this code at the end.
**/
var exitCode = 0;

/**
	Main function.
**/
function main() {
	final args = validateArguments();
	if(args != null) {
		runTests(args);
	}

	if(exitCode != 0) {
		Sys.exit(exitCode);
	}
}

/**
	Prints `errorString` to stderr and sets the `exitCode` to `1`.
**/
function error(errorString: String) {
	Sys.stderr().writeString(errorString);
	exitCode = 1;
}

/**
	Parses arguments and returns `Args` if valid.
	If not valid, returns `null`.
**/
function validateArguments(): Null<Args> {
	final args = {
		final args = Sys.args();
		switch(args.slice(0, 2)) {
			case [sillyScriptExecutable, unitTestFolder]: {
				executable: switch(Path.extension(sillyScriptExecutable)) {
					case "js": NodeJs(sillyScriptExecutable);
					case "hl": HashLink(sillyScriptExecutable);
					case _: Direct(sillyScriptExecutable);
				},
				tests: unitTestFolder,
				updateIntended: args.contains("--update-intended")
			}
			case _: {
				error("haxe --run Test.hx <path to SillyScript .exe/.hl/.js> <path to unit tests>");
				return null;
			}
		}
	};

	final path = switch(args.executable) {
		case NodeJs(path): path;
		case HashLink(path): path;
		case Direct(path): path;
	}
	if(!FileSystem.exists(path)) {
		error("Executable does not exist.");
		return null;
	}

	if(!FileSystem.exists(args.tests)) {
		error("Unit tests folder does not exist.");
		return null;
	}

	return args;
}

/**
	Runs all the tests by reading the directories in the provided unit-tests folder.
**/
function runTests(args: Args) {
	for(testFolder in FileSystem.readDirectory(args.tests)) {
		final path = Path.join([args.tests, testFolder]);
		switch(runTest(path, args.executable)) {
			case Success: {
				Sys.println(testFolder + " success!");
			}
			case TestSuccessfulButDoesntMatch(output) if(args.updateIntended): {
				File.saveContent(Path.join([path, "ExpectedOutput.json"]), cleanupContent(output));
				Sys.println(testFolder + " has been updated.");
			}
			case TestSuccessfulButNoExpectedOutputJson if(args.updateIntended): {
				final output = File.getContent(Path.join([path, "Output.json"]));
				File.saveContent(Path.join([path, "ExpectedOutput.json"]), cleanupContent(output));
				Sys.println(testFolder + " has been updated.");
			}
			case TestFailedButDoesntMatch(output) | TestFailedButNoExpectedError(output) if(args.updateIntended): {
				File.saveContent(Path.join([path, "ExpectedError.txt"]), cleanupContent(output));
				Sys.println(testFolder + " has been updated.");
			}
			case TestSuccessfulButNoExpectedOutputJson: {
				error(testFolder + " successfully compiled, but there's no ExpectedOutput.json.");
			}
			case TestSuccessfulButNoOutputJson: {
				error(testFolder + " successfully compiled, but didn't generate an Output.json.");
			}
			case TestSuccessfulButDoesntMatch(output): {
				error(testFolder + " successfully compiled, but doesn't match the intended output:\n" + output);
			}
			case TestFailedButNoExpectedError(stderrOutput): {
				error(testFolder + " failed, but there's no ExpectedError.txt.\n" + stderrOutput);
			}
			case TestFailedButDoesntMatch(newErrorOutput): {
				error(testFolder + " failed, but doesn't match the ExpectedError.txt:\n" + newErrorOutput);
			}
		}
	}
}

function runTest(folder: String, executable: ExecutableKind): RunTestResult {
	final sillyFiles = [];
	final expected = { error: null, output: null };
	for(file in FileSystem.readDirectory(folder)) {
		final filePath = Path.join([folder, file]);
		switch(file) {
			case "ExpectedError.txt": {
				expected.error = File.getContent(filePath);
			}
			case "ExpectedOutput.json": {
				expected.output = File.getContent(filePath);
			}
			case _ if(Path.extension(file) == "silly"): {
				sillyFiles.push(filePath);
			}
		}
	}

	if(sillyFiles.length > 0) {
		final sillyPath = sillyFiles[0];
		final outputPath = Path.join([Path.directory(sillyPath), "Output.json"]);
		final arguments = [sillyPath, outputPath, "--dont-color-errors"];
		final executable = switch(executable) {
			case Direct(path): path;
			case HashLink(path): {
				arguments.unshift(path);
				"hl";
			}
			case NodeJs(path): {
				arguments.unshift(path);
				"node";
			}
		}
		switch(run(executable, arguments)) {
			case Success: {
				if(expected.output == null) {
					return TestSuccessfulButNoExpectedOutputJson;
				}
				if(!FileSystem.exists(outputPath)) {
					return TestSuccessfulButNoOutputJson;
				}
				final output = File.getContent(outputPath);
				if(!areContentsSame(expected.output, output)) {
					return TestSuccessfulButDoesntMatch(output);
				}
			}
			case Error(stderrOutput): {
				if(expected.error == null) {
					return TestFailedButNoExpectedError(stderrOutput);
				}
				if(!areContentsSame(expected.error, stderrOutput)) {
					return TestFailedButDoesntMatch(stderrOutput);
				}
			}
		}
	}

	return Success;
}

inline function cleanupContent(content: String): String {
	return ~/\r/g.replace(content.trim(), "");
}

function areContentsSame(first: String, second: String): Bool {
	return cleanupContent(first) == cleanupContent(second);
}

function run(cmd: String, args: Array<String>): RunResult {
	final process = new Process(cmd, args);
	final exitCode = process.exitCode();
	final result = if(exitCode != 0) {
		Error(process.stderr.readAll().toString());
	} else {
		Success;
	}
	process.close();
	return result;
}

package test;

import haxe.io.Bytes;
import haxe.io.Path;
import sys.FileSystem;
import sys.io.File;
import sys.io.Process;
using StringTools;

/**
	Enum returned by `runTest`.
**/
enum RunTestResult {
	Success;
	NoSillyScriptFilesFound;
	TestSuccessfulButNoExpectedOutput;
	TestSuccessfulButNoOutputJson;
	TestSuccessfulButDoesntMatch(output: String);
	TestFailedButNoExpectedError(stderrOutput: String);
	TestFailedButDoesntMatch(newErrorOutput: String);
}

/**
	Enum returned by `run` for running an arbitrary command.
**/
enum RunResult {
	Success;
	Error(stderrOutput: String);
}

/**
	The kind of executable used for testing.
**/
enum ExecutableKind {
	Direct(path: String);
	HashLink(path: String);
	NodeJs(path: String);
}

/**
	The header of a single-file SillyScript test.
**/
enum Header {
	Invalid;
	OutputHeader(content: String, endCharacterIndex: Int);
	ErrorHeader(content: String, endCharacterIndex: Int);
}

/**
	Template for arguments object generated by `validateArguments`.
**/
typedef Args = {
	executable: ExecutableKind,
	tests: String,
	updateIntended: Bool
};

/**
	If not zero, this script will exit with this code at the end.
**/
var exitCode = 0;

/**
	Main function.
**/
function main() {
	final args = validateArguments();
	if(args != null) {
		runTests(args);
	}

	if(exitCode != 0) {
		Sys.exit(exitCode);
	}
}

/**
	Prints `errorString` to stderr and sets the `exitCode` to `1`.
**/
function error(errorString: String) {
	Sys.stderr().writeString(errorString);
	exitCode = 1;
}

/**
	Parses arguments and returns `Args` if valid.
	If not valid, returns `null`.
**/
function validateArguments(): Null<Args> {
	final args = {
		final args = Sys.args();
		switch(args.slice(0, 2)) {
			case [sillyScriptExecutable, unitTestFolder]: {
				executable: switch(Path.extension(sillyScriptExecutable)) {
					case "js": NodeJs(sillyScriptExecutable);
					case "hl": HashLink(sillyScriptExecutable);
					case _: Direct(sillyScriptExecutable);
				},
				tests: unitTestFolder,
				updateIntended: args.contains("--update-intended")
			}
			case _: {
				error("haxe --run Test.hx <path to SillyScript .exe/.hl/.js> <path to unit tests>");
				return null;
			}
		}
	};

	final path = switch(args.executable) {
		case NodeJs(path): path;
		case HashLink(path): path;
		case Direct(path): path;
	}
	if(!FileSystem.exists(path)) {
		error("Executable does not exist.");
		return null;
	}

	if(!FileSystem.exists(args.tests)) {
		error("Unit tests folder does not exist.");
		return null;
	}

	return args;
}

/**
	The regular expression used to parse the header for a single-file SillyScript test.
**/
inline function generateHeaderRegex(): EReg {
	return ~/^###[ \t]*(output|error)((.(?!^###$))+.)###\n\n/s;
}

/**
	Extracts the header content from a single-file SillyScript test.
**/
function extractHeaderContent(sillyScriptPath: String): Header {
	final originalContent = cleanupContent(File.getContent(sillyScriptPath));
	final re = generateHeaderRegex();
	return if(re.match(originalContent)) {
		final contents = re.matched(2);
		final endCharacterIndex = re.matched(0).length;
		switch(re.matched(1)) {
			case "output": OutputHeader(contents, endCharacterIndex);
			case "error": ErrorHeader(contents, endCharacterIndex);
			case _: Invalid;
		}
	} else {
		Invalid;
	}
}

/**
	Sets the header content for a single-file SillyScript test.
**/
function setHeaderContent(sillyScriptPath: String, content: String, kind: String) {
	final originalContent = File.getContent(sillyScriptPath);
	final code = switch(extractHeaderContent(sillyScriptPath)) {
		case OutputHeader(_, endCharacterIndex) | ErrorHeader(_, endCharacterIndex): {
			originalContent.substring(endCharacterIndex);
		}
		case Invalid: {
			originalContent;
		}
	}
	final finalContent = "### " + kind + "\n" + content + "\n###\n\n" + code;
	File.saveContent(sillyScriptPath, finalContent);
}

/**
	Runs all the tests by reading the directories in the provided unit-tests folder.
**/
function runTests(args: Args) {
	for(testEntry in FileSystem.readDirectory(args.tests)) {
		final path = Path.join([args.tests, testEntry]);
		final isDirectory = FileSystem.isDirectory(path);
		final isSingleFileTest = switch(Path.extension(testEntry)) {
			case "silly" if(!isDirectory): true;
			case _ if(isDirectory): false;
			case _: continue; // Ignore if not .silly or directory
		}

		switch(runTest(path, isSingleFileTest, args.executable)) {
			case Success: {
				Sys.println(testEntry + " success!");
			}
			case NoSillyScriptFilesFound: {
				error(testEntry + " had no .silly files...");
			}
			case TestSuccessfulButDoesntMatch(output) if(args.updateIntended): {
				if(isSingleFileTest) {
					setHeaderContent(path, cleanupContent(output), "output");
				} else {
					File.saveContent(Path.join([path, "ExpectedOutput.json"]), cleanupContent(output));
				}
				Sys.println(testEntry + " has been updated.");
			}
			case TestSuccessfulButNoExpectedOutput if(args.updateIntended): {
				final outputJsonPath = if(isSingleFileTest) {
					Path.join([args.tests, "Output.json"]);
				} else {
					Path.join([path, "Output.json"]);
				};
				final output = File.getContent(outputJsonPath);
				if(isSingleFileTest) {
					setHeaderContent(path, cleanupContent(output), "output");
				} else {
					File.saveContent(Path.join([path, "ExpectedOutput.json"]), cleanupContent(output));
				}
				Sys.println(testEntry + " has been updated.");
			}
			case TestFailedButDoesntMatch(output) | TestFailedButNoExpectedError(output) if(args.updateIntended): {
				if(isSingleFileTest) {
					setHeaderContent(path, cleanupContent(output), "error");
				} else {
					File.saveContent(Path.join([path, "ExpectedError.txt"]), cleanupContent(output));
				}
				Sys.println(testEntry + " has been updated.");
			}
			case TestSuccessfulButNoExpectedOutput: {
				error(testEntry + " successfully compiled, but there's no " + (isSingleFileTest ? "expected output header" : "ExpectedOutput.json") + ".");
			}
			case TestSuccessfulButNoOutputJson: {
				error(testEntry + " successfully compiled, but didn't generate an Output.json.");
			}
			case TestSuccessfulButDoesntMatch(output): {
				error(testEntry + " successfully compiled, but doesn't match the intended output:\n" + output);
			}
			case TestFailedButNoExpectedError(stderrOutput): {
				error(testEntry + " failed, but there's no " + (isSingleFileTest ? "expected error header" : "ExpectedError.txt") + ".\n" + stderrOutput);
			}
			case TestFailedButDoesntMatch(newErrorOutput): {
				error(testEntry + " failed, but doesn't match the intended error:\n" + newErrorOutput);
			}
		}
	}
}

function runTest(folderOrFile: String, isSingleFileTest: Bool, executable: ExecutableKind): RunTestResult {
	final sillyFiles = [];
	final expected = { error: null, output: null };
	if(isSingleFileTest) {
		sillyFiles.push(folderOrFile);
		switch(extractHeaderContent(folderOrFile)) {
			case OutputHeader(content, _): {
				expected.output = content;
			}
			case ErrorHeader(content, _): {
				expected.error = content;
			}
			case Invalid: {}
		}
	} else {
		for(file in FileSystem.readDirectory(folderOrFile)) {
			final filePath = Path.join([folderOrFile, file]);
			switch(file) {
				case "ExpectedError.txt": {
					expected.error = File.getContent(filePath);
				}
				case "ExpectedOutput.json": {
					expected.output = File.getContent(filePath);
				}
				case _ if(Path.extension(file) == "silly"): {
					sillyFiles.push(filePath);
				}
			}
		}
	}

	if(sillyFiles.length == 0) {
		return NoSillyScriptFilesFound;
	}

	final sillyPath = sillyFiles[0];
	final outputPath = Path.join([Path.directory(sillyPath), "Output.json"]);
	final arguments = [sillyPath, outputPath, "--dont-color-errors"];
	final executable = switch(executable) {
		case Direct(path): path;
		case HashLink(path): {
			arguments.unshift(path);
			"hl";
		}
		case NodeJs(path): {
			arguments.unshift(path);
			"node";
		}
	}
	switch(run(executable, arguments)) {
		case Success: {
			if(expected.output == null) {
				return TestSuccessfulButNoExpectedOutput;
			}
			if(!FileSystem.exists(outputPath)) {
				return TestSuccessfulButNoOutputJson;
			}
			final output = File.getContent(outputPath);
			if(!areContentsSame(expected.output, output)) {
				return TestSuccessfulButDoesntMatch(output);
			}
		}
		case Error(stderrOutput): {
			if(expected.error == null) {
				return TestFailedButNoExpectedError(stderrOutput);
			}
			if(!areContentsSame(expected.error, stderrOutput)) {
				return TestFailedButDoesntMatch(stderrOutput);
			}
		}
	}

	return Success;
}

inline function cleanupContent(content: String): String {
	return ~/\r/g.replace(content.trim(), "");
}

function areContentsSame(first: String, second: String): Bool {
	return cleanupContent(first) == cleanupContent(second);
}

function run(cmd: String, args: Array<String>): RunResult {
	final process = new Process(cmd, args);
	final exitCode = process.exitCode();
	final result = if(exitCode != 0) {
		Error(process.stderr.readAll().toString());
	} else {
		Success;
	}
	process.close();
	return result;
}
